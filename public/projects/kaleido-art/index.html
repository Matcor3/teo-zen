<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KaleidoArt - Elements Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Slider Styles */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #60a5fa;
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 2px;
        }

        .tool-panel {
            backdrop-filter: blur(12px);
            background-color: rgba(20, 20, 20, 0.9);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .hidden-panel {
            transform: translateX(-110%);
        }

        .btn-icon {
            transition: all 0.2s;
        }
        .btn-icon:active {
            transform: scale(0.95);
        }
        
        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed !important;
            pointer-events: none;
            filter: grayscale(100%);
        }

        /* Custom Checkbox Style for Effects */
        .effect-checkbox {
            appearance: none;
            width: 1.2rem;
            height: 1.2rem;
            border-radius: 0.25rem;
            background-color: #374151;
            border: 1px solid #4b5563;
            cursor: pointer;
            position: relative;
        }
        .effect-checkbox:checked {
            background-color: currentColor;
            border-color: currentColor;
        }
        .effect-checkbox:checked::after {
            content: 'âœ”';
            position: absolute;
            color: white;
            font-size: 0.8rem;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>

    <!-- Container Principale -->
    <div id="canvas-container">
        <canvas id="artCanvas"></canvas>
    </div>

    <!-- Pannello Strumenti -->
    <div id="toolbar" class="tool-panel fixed top-4 left-4 p-5 rounded-2xl border border-gray-700 shadow-2xl w-80 text-gray-200 z-50 max-h-[95vh] overflow-y-auto scrollbar-hide">
        
        <div class="flex justify-between items-center mb-4 border-b border-gray-600 pb-2">
            <h1 class="text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">KaleidoArt</h1>
            <button id="toggle-hide" class="text-gray-400 hover:text-white transition">
                <i class="fas fa-chevron-left"></i>
            </button>
        </div>

        <!-- Sezione Colore -->
        <div class="mb-5 bg-gray-800/50 p-3 rounded-lg">
            <div class="flex items-center justify-between mb-2">
                <label class="text-xs uppercase tracking-wider text-gray-400">Colore</label>
                <div class="flex items-center gap-2">
                    <span id="hexValue" class="text-xs font-mono text-gray-500">#00d2ff</span>
                    <input type="color" id="colorPicker" value="#00d2ff" class="h-6 w-6 bg-transparent border-0 cursor-pointer rounded overflow-hidden">
                </div>
            </div>
            <div class="flex items-center gap-2">
                <input type="checkbox" id="rainbowMode" class="w-4 h-4 rounded border-gray-600 text-blue-500 bg-gray-700">
                <label for="rainbowMode" class="text-sm cursor-pointer select-none text-gray-300">Arcobaleno ðŸŒˆ</label>
            </div>
        </div>

        <!-- Sezione Dimensione & Simmetria -->
        <div class="mb-5 grid grid-cols-2 gap-4">
            <div>
                <label class="block text-xs uppercase tracking-wider text-gray-400 mb-1">Dimensione</label>
                <input type="range" id="brushSize" min="1" max="50" value="3" class="w-full">
            </div>
            <div>
                <label class="block text-xs uppercase tracking-wider text-gray-400 mb-1">Simmetria: <span id="symmetryValue" class="text-blue-400">4</span></label>
                <input type="range" id="symmetryCount" min="1" max="24" value="4" class="w-full">
            </div>
        </div>

        <!-- Effetti Speciali -->
        <div class="mb-6">
            <label class="block text-xs uppercase tracking-wider text-gray-400 mb-2 border-b border-gray-700 pb-1">Effetti Speciali</label>
            
            <div class="space-y-2">
                <!-- Glow & Mirror (Base) -->
                <div class="flex gap-4 mb-2">
                    <label class="flex items-center gap-2 text-xs cursor-pointer">
                        <input type="checkbox" id="glowEffect" class="w-3 h-3 rounded text-purple-500 bg-gray-700">
                        Neon
                    </label>
                    <label class="flex items-center gap-2 text-xs cursor-pointer">
                        <input type="checkbox" id="mirrorX" class="w-3 h-3 rounded text-green-500 bg-gray-700">
                        Specchio X
                    </label>
                </div>

                <!-- ModalitÃ  Esclusive -->
                <div class="bg-gray-900/40 p-2 rounded border border-gray-700/50 space-y-2">
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="silkEffect" class="effect-checkbox text-blue-400">
                        <label for="silkEffect" class="text-sm cursor-pointer select-none text-blue-200"><i class="fas fa-wind mr-1"></i> Seta (Silk)</label>
                    </div>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="fireEffect" class="effect-checkbox text-orange-500">
                        <label for="fireEffect" class="text-sm cursor-pointer select-none text-orange-200"><i class="fas fa-fire mr-1"></i> Fuoco</label>
                    </div>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="waterEffect" class="effect-checkbox text-cyan-400">
                        <label for="waterEffect" class="text-sm cursor-pointer select-none text-cyan-200"><i class="fas fa-tint mr-1"></i> Acqua</label>
                    </div>
                    <div class="flex items-center gap-2">
                        <input type="checkbox" id="branchEffect" class="effect-checkbox text-green-600">
                        <label for="branchEffect" class="text-sm cursor-pointer select-none text-green-200"><i class="fas fa-code-branch mr-1"></i> Rami / Fulmini</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Azioni & Animazione -->
        <div class="space-y-3">
            <div class="grid grid-cols-2 gap-2">
                <button id="clearBtn" class="btn-icon bg-gray-700 hover:bg-gray-600 text-white py-2 rounded text-xs uppercase font-bold tracking-wide transition-colors">
                    <i class="fas fa-trash-alt mr-1"></i> Pulisci
                </button>
                <button id="saveBtn" class="btn-icon bg-gray-700 hover:bg-gray-600 text-white py-2 rounded text-xs uppercase font-bold tracking-wide transition-colors">
                    <i class="fas fa-camera mr-1"></i> Foto
                </button>
            </div>

            <div class="bg-indigo-900/20 p-3 rounded-lg border border-indigo-500/30">
                <div class="flex justify-between items-center mb-2">
                    <label class="text-[10px] uppercase text-indigo-300 font-bold">Animazione</label>
                    <span id="speedValue" class="text-[10px] text-indigo-300">Vel: 1x</span>
                </div>
                
                <input type="range" id="animSpeed" min="1" max="10" value="5" class="w-full mb-3 h-1 bg-indigo-900 rounded">

                <div class="grid grid-cols-2 gap-2">
                    <button id="animateBtn" class="btn-icon bg-indigo-600 hover:bg-indigo-500 text-white py-2 rounded text-xs font-bold transition-colors shadow-lg shadow-indigo-500/20">
                        <i class="fas fa-play mr-1"></i> Play
                    </button>
                    <button id="saveVideoBtn" class="btn-icon bg-purple-600 hover:bg-purple-500 text-white py-2 rounded text-xs font-bold transition-colors shadow-lg shadow-purple-500/20">
                        <i class="fas fa-video mr-1"></i> Video
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Pulsante Menu -->
    <button id="show-toolbar" class="fixed top-4 left-4 z-40 bg-gray-800 p-3 rounded-full text-white shadow-lg border border-gray-600 hidden hover:bg-gray-700">
        <i class="fas fa-bars"></i>
    </button>

    <!-- Overlay Istruzioni -->
    <div id="intro-overlay" class="fixed inset-0 bg-black/90 z-[100] flex items-center justify-center text-center p-4 backdrop-blur-sm">
        <div class="max-w-md animate-bounce-in">
            <div class="text-5xl mb-4">âœ¨</div>
            <h2 class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 mb-3">KaleidoArt Elements</h2>
            <p class="text-gray-400 mb-6 text-sm leading-relaxed">
                Nuovi effetti disponibili:<br>
                <span class="text-orange-400">ðŸ”¥ Fuoco</span> â€¢ 
                <span class="text-cyan-400">ðŸ’§ Acqua</span> â€¢ 
                <span class="text-green-400">ðŸŒ³ Rami</span><br><br>
                KaleidoArt by Teo Zen
            </p>
            <button id="startBtn" class="bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 text-white px-8 py-3 rounded-full font-bold text-lg transition transform hover:scale-105 shadow-xl">
                Inizia a Disegnare
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('artCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, centerX, centerY;
        let dpr = 1;

        // Stato Applicazione
        const state = {
            isDrawing: false,
            isAnimating: false,
            lastX: 0,
            lastY: 0,
            hue: 0,
            color: '#00d2ff',
            size: 3,
            symmetry: 4,
            rainbow: false,
            glow: false,
            mirrorX: false,
            // Modes (Esclusivi)
            mode: 'normal', // normal, silk, fire, water, branch
            history: []
        };

        // UI References
        const ui = {
            colorPicker: document.getElementById('colorPicker'),
            hexValue: document.getElementById('hexValue'),
            brushSize: document.getElementById('brushSize'),
            symmetryCount: document.getElementById('symmetryCount'),
            symmetryValue: document.getElementById('symmetryValue'),
            rainbowMode: document.getElementById('rainbowMode'),
            glowEffect: document.getElementById('glowEffect'),
            mirrorX: document.getElementById('mirrorX'),
            // Effects
            silkEffect: document.getElementById('silkEffect'),
            fireEffect: document.getElementById('fireEffect'),
            waterEffect: document.getElementById('waterEffect'),
            branchEffect: document.getElementById('branchEffect'),
            // Actions
            clearBtn: document.getElementById('clearBtn'),
            saveBtn: document.getElementById('saveBtn'),
            animateBtn: document.getElementById('animateBtn'),
            saveVideoBtn: document.getElementById('saveVideoBtn'),
            animSpeed: document.getElementById('animSpeed'),
            speedValue: document.getElementById('speedValue'),
            // Panels
            toolbar: document.getElementById('toolbar'),
            toggleHide: document.getElementById('toggle-hide'),
            showToolbar: document.getElementById('show-toolbar'),
            introOverlay: document.getElementById('intro-overlay'),
            startBtn: document.getElementById('startBtn')
        };

        // --- Inizializzazione ---
        function resize() {
            dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
            
            if(!state.isAnimating) clearCanvas();
        }

        function clearCanvas() {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

        window.addEventListener('resize', resize);
        resize();

        // --- Helpers ---
        function getPos(e) {
            const t = e.touches ? e.touches[0] : e;
            return { x: t.clientX, y: t.clientY };
        }
        function random(min, max) { return Math.random() * (max - min) + min; }
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- Core Logic ---
        function draw(e) {
            if (!state.isDrawing || state.isAnimating) return;
            e.preventDefault(); 
            const pos = getPos(e);
            
            let col = state.color;
            if (state.rainbow) {
                state.hue = (state.hue + 1) % 360;
                col = `hsl(${state.hue}, 100%, 60%)`;
            }

            const step = {
                start: { x: state.lastX, y: state.lastY },
                end: { x: pos.x, y: pos.y },
                settings: {
                    size: state.size,
                    color: col,
                    glow: state.glow,
                    symmetry: state.symmetry,
                    mirrorX: state.mirrorX,
                    mode: state.mode
                }
            };

            redrawStep(step);
            state.history.push(step);
            state.lastX = pos.x;
            state.lastY = pos.y;
        }

        function redrawStep(step) {
            const { start, end, settings } = step;
            const mode = settings.mode;

            // Setup Context Base
            ctx.save();
            ctx.translate(centerX, centerY);
            
            // Common vars
            const lastRx = start.x - centerX;
            const lastRy = start.y - centerY;
            const curRx = end.x - centerX;
            const curRy = end.y - centerY;
            const angleStep = (Math.PI * 2) / settings.symmetry;

            // Prepare Style based on Mode
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            if (mode === 'fire') {
                ctx.globalCompositeOperation = 'lighter';
                ctx.shadowBlur = 15;
                ctx.shadowColor = settings.color;
                ctx.strokeStyle = settings.color; // Use alpha in draw fn
            } else if (mode === 'water') {
                ctx.globalCompositeOperation = 'source-over'; // Liquid feeling
                ctx.shadowBlur = 5;
                ctx.shadowColor = settings.color;
                ctx.strokeStyle = settings.color;
            } else if (mode === 'silk') {
                ctx.globalCompositeOperation = 'lighter';
                ctx.shadowBlur = 5;
                ctx.shadowColor = settings.color;
            } else if (mode === 'branch') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineCap = 'butt';
                ctx.shadowBlur = 0;
                ctx.strokeStyle = settings.color;
            } else {
                // Normal
                ctx.globalCompositeOperation = settings.glow ? 'lighter' : 'source-over';
                ctx.shadowBlur = settings.glow ? 15 : 0;
                ctx.shadowColor = settings.color;
                ctx.strokeStyle = settings.color;
                ctx.lineWidth = settings.size;
            }

            // Drawing Strategy Pattern
            const strategies = {
                normal: (p1x, p1y, p2x, p2y) => {
                    ctx.beginPath();
                    ctx.moveTo(p1x, p1y);
                    // Smooth curve
                    ctx.quadraticCurveTo(p1x, p1y, (p1x+p2x)/2, (p1y+p2y)/2); 
                    ctx.lineTo(p2x, p2y);
                    ctx.stroke();
                },
                silk: (p1x, p1y, p2x, p2y) => {
                    ctx.lineWidth = Math.max(0.5, settings.size / 5);
                    // Force low opacity for silk effect
                    const baseColor = settings.color.startsWith('#') ? hexToRgba(settings.color, 0.1) : settings.color.replace(')', ', 0.1)');
                    ctx.strokeStyle = baseColor;
                    
                    const spread = settings.size * 2;
                    for (let k = 0; k < 5; k++) {
                        ctx.beginPath();
                        ctx.moveTo(p1x, p1y);
                        ctx.quadraticCurveTo(
                            (p1x+p2x)/2 + random(-spread, spread), 
                            (p1y+p2y)/2 + random(-spread, spread), 
                            p2x + random(-spread/2, spread/2), 
                            p2y + random(-spread/2, spread/2)
                        );
                        ctx.stroke();
                    }
                },
                fire: (p1x, p1y, p2x, p2y) => {
                    // Fire is jittery and moves "up" visually or radially out
                    const dist = Math.sqrt((p2x-p1x)**2 + (p2y-p1y)**2);
                    const sparks = Math.max(3, settings.size);
                    
                    // Main core
                    ctx.lineWidth = settings.size;
                    ctx.strokeStyle = settings.color.startsWith('#') ? hexToRgba(settings.color, 0.8) : settings.color;
                    ctx.beginPath();
                    ctx.moveTo(p1x, p1y);
                    ctx.lineTo(p2x, p2y);
                    ctx.stroke();

                    // Flames
                    ctx.lineWidth = settings.size / 2;
                    ctx.strokeStyle = settings.color.startsWith('#') ? hexToRgba(settings.color, 0.3) : settings.color.replace(')', ', 0.3)');
                    
                    for(let k=0; k<sparks; k++) {
                        const offsetX = random(-settings.size*3, settings.size*3);
                        const offsetY = random(-settings.size*3, settings.size*3);
                        ctx.beginPath();
                        ctx.moveTo(p1x, p1y);
                        // Jittery path
                        ctx.lineTo(p2x + offsetX, p2y + offsetY);
                        ctx.stroke();
                    }
                },
                water: (p1x, p1y, p2x, p2y) => {
                    // Wide, soft, overlapping strokes
                    const baseWidth = settings.size * 3;
                    
                    // Layer 1: Wide & Transparent
                    ctx.lineWidth = baseWidth;
                    ctx.strokeStyle = settings.color.startsWith('#') ? hexToRgba(settings.color, 0.1) : settings.color.replace(')', ', 0.1)');
                    ctx.beginPath();
                    ctx.moveTo(p1x, p1y);
                    ctx.quadraticCurveTo((p1x+p2x)/2 + random(-2,2), (p1y+p2y)/2 + random(-2,2), p2x, p2y);
                    ctx.stroke();

                    // Layer 2: Thin & Sharper reflection
                    ctx.lineWidth = settings.size / 2;
                    ctx.strokeStyle = settings.color.startsWith('#') ? hexToRgba(settings.color, 0.4) : settings.color.replace(')', ', 0.4)');
                    ctx.beginPath();
                    ctx.moveTo(p1x + random(-5,5), p1y + random(-5,5));
                    ctx.lineTo(p2x, p2y);
                    ctx.stroke();
                },
                branch: (p1x, p1y, p2x, p2y) => {
                    // Jagged line
                    ctx.lineWidth = settings.size;
                    const midX = (p1x + p2x) / 2;
                    const midY = (p1y + p2y) / 2;
                    // Add noise perpendicular to direction
                    const noise = settings.size * 2; 
                    const jX = midX + random(-noise, noise);
                    const jY = midY + random(-noise, noise);

                    ctx.beginPath();
                    ctx.moveTo(p1x, p1y);
                    ctx.lineTo(jX, jY);
                    ctx.lineTo(p2x, p2y);
                    ctx.stroke();
                }
            };

            const drawFn = strategies[mode] || strategies.normal;

            for (let i = 0; i < settings.symmetry; i++) {
                ctx.rotate(angleStep);
                drawFn(lastRx, lastRy, curRx, curRy);
                if (settings.mirrorX) {
                    ctx.save();
                    ctx.scale(1, -1);
                    drawFn(lastRx, lastRy, curRx, curRy);
                    ctx.restore();
                }
            }
            ctx.restore();
        }

        // --- Gestione Effetti Esclusivi ---
        const effectCheckboxes = [ui.silkEffect, ui.fireEffect, ui.waterEffect, ui.branchEffect];
        
        function setMode(newMode, checkbox) {
            // Se clicco su un box giÃ  attivo, lo disattivo e torno a normal
            if (!checkbox.checked) {
                state.mode = 'normal';
                return;
            }
            // Altrimenti attivo il nuovo e spengo gli altri
            state.mode = newMode;
            effectCheckboxes.forEach(cb => {
                if (cb !== checkbox) cb.checked = false;
            });
            // Auto-disable glow for complex effects to control performance/look
            if(newMode !== 'normal') {
                state.glow = false;
                ui.glowEffect.checked = false;
            }
        }

        ui.silkEffect.addEventListener('change', (e) => setMode('silk', e.target));
        ui.fireEffect.addEventListener('change', (e) => setMode('fire', e.target));
        ui.waterEffect.addEventListener('change', (e) => setMode('water', e.target));
        ui.branchEffect.addEventListener('change', (e) => setMode('branch', e.target));

        // --- Animazione ---
        let mediaRecorder, recordedChunks = [];

        function toggleUI(enable) {
            const method = enable ? 'remove' : 'add';
            ui.animateBtn.classList[method]('btn-disabled');
            ui.saveVideoBtn.classList[method]('btn-disabled');
            ui.clearBtn.classList[method]('btn-disabled');
            ui.toolbar.querySelectorAll('input').forEach(el => el.disabled = !enable);
        }

        function playAnimation(record = false) {
            if (state.history.length === 0 || state.isAnimating) return;
            state.isAnimating = true;
            toggleUI(false);
            clearCanvas();

            if (record) startRecording();

            let historyIndex = 0;
            // Calcolo velocitÃ  basato su slider (1 = lento, 10 = veloce)
            // Slider value 1 -> 1 step per frame. Slider 10 -> 20 steps per frame?
            // O meglio: Slider 1 -> Speedfactor 0.5. Slider 10 -> Speedfactor 5.
            
            function animateFrame() {
                const speedVal = parseInt(ui.animSpeed.value);
                // Logica velocitÃ :
                // VelocitÃ  base variabile in base alla lunghezza cronologia, modulata dallo slider
                // Se history Ã¨ corta (100 passi), speed 1 = 1 passo/frame.
                // Se history Ã¨ lunga (2000 passi), vogliamo che speed 5 sia comunque guardabile.
                
                // Base multiplier: 1 (min) a 10 (max)
                const stepsPerFrame = Math.max(1, Math.floor(speedVal * (state.history.length / 1000 + 0.5)));

                if (historyIndex < state.history.length) {
                    for(let i = 0; i < stepsPerFrame && historyIndex < state.history.length; i++) {
                        redrawStep(state.history[historyIndex]);
                        historyIndex++;
                    }
                    requestAnimationFrame(animateFrame);
                } else {
                    state.isAnimating = false;
                    toggleUI(true);
                    if (record) stopRecording();
                }
            }
            setTimeout(() => requestAnimationFrame(animateFrame), 100);
        }

        // --- Recording Logic ---
        function startRecording() {
            recordedChunks = [];
            const stream = canvas.captureStream(30);
            const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm';
            mediaRecorder = new MediaRecorder(stream, { mimeType: mime });
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `kaleido-art-${Date.now()}.webm`;
                a.click();
                URL.revokeObjectURL(url);
            };
            mediaRecorder.start();
            ui.saveVideoBtn.innerHTML = '<i class="fas fa-circle text-red-500 animate-pulse mr-1"></i> Rec';
        }
        function stopRecording() {
            if(mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                ui.saveVideoBtn.innerHTML = '<i class="fas fa-video mr-1"></i> Video';
            }
        }

        // --- Event Listeners Base ---
        ui.animSpeed.addEventListener('input', (e) => ui.speedValue.textContent = `Vel: ${e.target.value}x`);
        
        function startDraw(e) { 
            if(state.isAnimating) return;
            state.isDrawing = true; 
            const p = getPos(e); 
            state.lastX = p.x; state.lastY = p.y; 
        }
        function endDraw() { state.isDrawing = false; ctx.beginPath(); }
        
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseout', endDraw);
        canvas.addEventListener('touchstart', startDraw, {passive:false});
        canvas.addEventListener('touchmove', draw, {passive:false});
        canvas.addEventListener('touchend', endDraw);

        ui.colorPicker.addEventListener('input', (e) => { state.color = e.target.value; ui.hexValue.textContent = e.target.value; state.rainbow = false; ui.rainbowMode.checked = false; });
        ui.brushSize.addEventListener('input', (e) => state.size = parseInt(e.target.value));
        ui.symmetryCount.addEventListener('input', (e) => { state.symmetry = parseInt(e.target.value); ui.symmetryValue.textContent = state.symmetry; });
        ui.rainbowMode.addEventListener('change', (e) => state.rainbow = e.target.checked);
        ui.glowEffect.addEventListener('change', (e) => state.glow = e.target.checked);
        ui.mirrorX.addEventListener('change', (e) => state.mirrorX = e.target.checked);
        
        ui.clearBtn.addEventListener('click', () => { if(!state.isAnimating) { clearCanvas(); state.history = []; } });
        ui.saveBtn.addEventListener('click', () => { if(!state.isAnimating) { const l = document.createElement('a'); l.download = `art-${Date.now()}.png`; l.href = canvas.toDataURL(); l.click(); } });
        ui.animateBtn.addEventListener('click', () => playAnimation(false));
        ui.saveVideoBtn.addEventListener('click', () => { if(state.history.length) playAnimation(true); else alert("Disegna prima qualcosa!"); });

        // Pannelli
        ui.toggleHide.addEventListener('click', () => { ui.toolbar.classList.add('hidden-panel'); ui.showToolbar.classList.remove('hidden'); });
        ui.showToolbar.addEventListener('click', () => { ui.toolbar.classList.remove('hidden-panel'); ui.showToolbar.classList.add('hidden'); });
        ui.startBtn.addEventListener('click', () => { ui.introOverlay.style.opacity = '0'; setTimeout(()=>ui.introOverlay.style.display='none', 500); });

    </script>
</body>
</html>